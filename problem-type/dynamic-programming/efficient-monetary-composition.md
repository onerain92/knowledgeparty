---
description: '문제 난이도: 중 / 문제 풀이 시간 : 30분 / 시간 제한 : 1초 / 메모리 제한 : 128MB'
---

# 효율적인 화폐 구성

## 문제 설명

N가지 종류의 화폐가 있다. 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 하려고 한다. 이때 각 화폐는 몇 개라도 사용할 수 있으며, 사용한 화폐의 구성은 같지만 순서만 다른 것은 같은 경우로 구분한다. 예를 들어 2원, 3원 단위의 화폐가 있을 때는 15원을 만들기 위해 3원을 5개 사용하는 것이 가장 최소한의 화폐 개수이다.

#### 입력 조건

* 첫째 줄에 N, M이 주어딘다. \( 1 &lt;= N &lt;= 100, 1 &lt;= M &lt;= 10,000 \)
* 이후의 N개의 줄에는 각 화폐의 가치가 주어진다. 화폐의 가치는 10,000보다 작거나 같은 자연수이다.

#### 출력 조건

* 첫째 줄에 경우의 수 X를 출력한다.
* 불가능할 때는 -1을 출력한다.

#### 입력 예시

2 15  
2  
3

#### 출력 예시

5



## 문제 해설

적은 금액부터 큰 금액까지 확인하며 차례대로 만들 수 있는 최소한의 화폐 개수를 찾으면 된다. 금액 i를 만들 수 있는 최소한의 화폐 개수를 ai, 화폐의 단위를 k라고 했을 때 다음과 같이 점화식을 작성할 수 있다. a\(i-k\)는 금액 \(i - k\)를 만들 수 있는 최소한의 화폐 개수를 의미한다.

* a\(i-k\)를 만드는 방법이 존재하는 경우, ai = min\( ai, a\(i-k\) + 1 \)
* a\(i-k\)를 만드는 방법이 존재하지 않는 경우, ai = 10,001

## 답안

### 내가 푼 답안

```text
def solution(n, m, monetarys):
    dp = [10001] * (m + 1)
    dp[0] = 0

    for i in range(n):
        for j in range(monetarys[i], m + 1):
            if dp[j - monetarys[i]] != 10001:
                dp[j] = min(dp[j], dp[j - monetarys[i]] + 1)

    if dp[m] == 10001:
        return -1
    else:
        return dp[m]


print(solution(2, 15, [2, 3]))
print(solution(3, 7, [2, 3, 5]))
print(solution(3, 4, [3, 5, 7]))
```



