# 그래프

## 서로소 집합

* **서로소 집합**이란 **공통 원소가 없는 두 집합**을 의미한다.
* 예를 들어 두 집합 \[1, 2\]와 \[3, 4\]는 서로소 관계이다.
* 서로소 집합 자료구조란 _**서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조**_라고 할 수 있다.
* 서로소 집합 자료구조는 union과 find 이 2개의 연산으로 조작할 수 있다.
* union\( 합집합 \) 연산은 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산이다.
* find\( 찾기 \) 연산은 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산이다.
* 스택과 큐가 각각 push와 pop 연산으로 이루어졌던 것처럼, 서로소 집합 자료구조는 합집합과 찾기 연산으로 구성된다.
* 서로소 집합 자료구조는 union-find\( 합치기 찾기 \) 자료구조라고 불리며, 두 집합이 서로소 관계인지를 확인할 수 있다는 말은 각 집합이 어떤 원소를 공통으로 가지고 있는지를 확인할 수 있다는 말과 같기 때문이다.
* 서로소 집합 자료구조를 구현할 때는 트리 자료구조를 이용하여 집합을 표현하는데, 서로소 집합 정보\( 합집합 연산 \)가 주어졌을 때 트리 자료구조를 이용해서 집합을 표현하는 서로소 집합 계산 알고리즘은 다음과 같다.
  * union\( 합집합 \) 연산을 확인하여, 서로 연결된 두 노드 A, B를 확인한다.
    * A와 B의 루트 노드 A', B'를 각각 찾는다.
    * A'를 B'의 부모 노드로 설정한다.\( B'가 A'를 가리키도록 한다. \)
  * 모든 union\( 합집합 \) 연산을 처리할 때까지 위 과정을 반복한다.
* 일반적으로 A'와 B' 중에서 더 번호가 작은 원소가 부모 노드가 되도록 구현하는 경우가 많다.



### 기본적인 서로소 집합 알고리즘 코드

```text
# 특정 원소가 속한 집합을 찾기
def find_parent(parent, x):
    # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출
    if parent[x] != x:
        return find_parent(parent, parent[x])
    return x

    
# 두 원소가 속한 집합을 합치기
def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    
    if a < b:
        parent[b] = a
    else:
        parent[a] = b
        

# 노드의 개수와 간선( union 연산 )의 개수 입력받기
v, e = map(int, input().split())
parent = [0] * (v + 1) # 부모 테이블 초기화

# 부모 테이블상에서, 부모를 자기 자신으로 초기화
for i in range(1, v + 1):
    parent[i] = i
    
# union 연산을 각각 수행
for i in range(e):
    a, b = map(int, input().split())
    union_parent(parent, a, b)

# 각 원소가 속한 집합 출력
print('각 원소가 속한 집합: ', end='')
for i in range(1, v + 1):
    print(find_parent(parent, i), end=' ')
    
print()

# 부모 테이블 내용 출력
print('부모 테이블: ', end='')
for i in range(1, v + 1):
    print(parent[i], end=' ')
```



### 개선된 서로소 집합 알고리즘 코드

```text
# 특정 원소가 속한 집합을 찾기
def find_parent(parent, x):
    # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출
    if parent[x] != x:
        return find_parent(parent, parent[x])
    return parent[x]

    
# 두 원소가 속한 집합을 합치기
def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    
    if a < b:
        parent[b] = a
    else:
        parent[a] = b
        

# 노드의 개수와 간선( union 연산 )의 개수 입력받기
v, e = map(int, input().split())
parent = [0] * (v + 1) # 부모 테이블 초기화

# 부모 테이블상에서, 부모를 자기 자신으로 초기화
for i in range(1, v + 1):
    parent[i] = i
    
# union 연산을 각각 수행
for i in range(e):
    a, b = map(int, input().split())
    union_parent(parent, a, b)

# 각 원소가 속한 집합 출력
print('각 원소가 속한 집합: ', end='')
for i in range(1, v + 1):
    print(find_parent(parent, i), end=' ')
    
print()

# 부모 테이블 내용 출력
print('부모 테이블: ', end='')
for i in range(1, v + 1):
    print(parent[i], end=' ')
```



### 서로소 집합 알고리즘의 시간 복잡도

노드의 개수가 V개이고, 최대 V - 1개의 union 연산과 M개의 find 연산이 가능할 때 경로 압축 방법을 적용한 시간 복잡도는 O\( V + M\( 1 + log\(2-M/V\) V \) \)라는 것이 알려져 있다. 예를 들어 노드의 개수가 1,000개이고, union 및 find 연산이 총 100만 번 수행된다고 하자. 그러면 이 경우 정확하지는 않지만, 대략 V + M log\(2\) V를 계산해서 약 1,000만 번 가량의 연산이 필요하다고 이해하면 된다.



### 서로소 집합을 활용한 사이클 판별

* 서로소 집합은 무방향 그래프 내에서의 사이클을 판별할 때 사용할 수 있다. 참고로 방향 그래프에서의 사이클 여부는 DFS를 이용하여 판별할 수 있다.
* union 연산은 그래프에서의 간선으로 표현될 수 있으므로 간선을 하나씩 확인하면서 두 노드가 포함되어 있는 집합을 합치는 과정을 반복하는 것만으로도 사이클을 판별할 수 있다.
  * 각 간선을 확인하며 두 노드의 루트 노드를 확인한다.
    * 루트 노드가 서로 다르다면 두 노드에 대하여 union 연산을 수행한다.
    * 루트 노드가 서로 같다면 사이클\( Cycle \)이 발생한 것이다.
  * 그래프에 포함되어 있는 모든 간선에 대하여 위 과정을 반복한다.
* 이러한 사이클 판별 알고리즘은 그래프에 포함되어 있는 간선의 개수가 E개일 때 모든 간선을 하나씩 확인하며, 매 간선에 대하여 union 및 find 함수를 호출하는 방식으로 동작한다.
* 이 알고리즘은 간선에 방향성이 없는 무방향 그래프에서만 적용 가능하다.

```text
# 특정 원소가 속한 집합을 찾기
def find_parent(parent, x):
    # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출
    if parent[x] != x:
        return find_parent(parent, parent[x])
    return parent[x]

    
# 두 원소가 속한 집합을 합치기
def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    
    if a < b:
        parent[b] = a
    else:
        parent[a] = b
        

# 노드의 개수와 간선( union 연산 )의 개수 입력받기
v, e = map(int, input().split())
parent = [0] * (v + 1) # 부모 테이블 초기화

# 부모 테이블상에서, 부모를 자기 자신으로 초기화
for i in range(1, v + 1):
    parent[i] = i
    
cycle = False # 사이클 발생 여부
    
# union 연산을 각각 수행
for i in range(e):
    a, b = map(int, input().split())
    
    # 사이클이 발생한 경우 종료
    if find_parent(parent, a) == find_parent(parent, b):
        cycle = True
        break
    # 사이클이 발생하지 않았다면 합집합( union ) 수행
    else:
        union_parent(parent, a, b)

if cycle:
    print('사이클이 발생했습니다.')
else:
    print('사이클이 발생하지 않았습니다.')
```



## 신장 트리

* 신장 트리\( Spanning Tree \)란 _**하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프**_를 의미한다.
* 이때 모든 노드가 포함되어 서로 연결되면서 사이클이 존재하지 않는다는 조건은 트리의 성립 조건이기도 하다.
* 신장 트리 중에서 최소 비용으로 만들 수 있는 신장 트리를 찾는 알고리즘을 _**'최소 신장 트리 알고리즘'**_이라고 한다.
* 최소 신장 트리는 일종의 트리 자료구조이므로, 최종적으로 신장 트리에 포함되는 간선의 개수가 '노드의 개수 - 1'과 같다는 특징이 있다.



## 크루스칼 알고리즘\( Kruskal Algorithm \)

* 크루스칼 알고리즘을 사용하면 가장 적은 비용으로 모든 노드를 연결할 수 있는데 크루스칼 알고리즘은 그리디 알고리즘으로 분류된다.
* 먼저 모든 간선에 대하여 정렬을 수행한 뒤에 가장 거리가 짧은 간선부터 집합에 포함시키면 된다.
* 이때 사이클을 발생시킬 수 있는 간선의 경우, 집합에 포함시키지 않는다.
  * 간선 데이터를 비용에 따라 오름차순으로 정렬한다.
  * 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인한다.
    * 사이클이 발생하지 않는 경우 최소 신장 트리에 포함시킨다.
    * 사이클이 발생하는 경우 최소 신장 트리에 포함시키지 않는다.
  * 모든 간선에 대하여 위의 과정을 반복한다.
* 크루스칼 알고리즘의 핵심 원리는 가장 거리가 짧은 간선부터 차례대로 집합에 추가하면 된다. 다만 사이클을 발생시키는 간선을 제외하고 연결한다. 이렇게 하면 항상 최적의 해를 보장할 수 있다.

#### 크루스칼 알고리즘을 이용해서 최소 신장 트리를 찾는 과정

1. 초기 단계에서는 그래프의 모든 간선 정보만 따로 빼내어 정렬을 수행한다.

| 간선 | \(1, 2\) | \(1, 5\) | \(2, 3\) | \(2, 6\) | \(3, 4\) | \(4, 6\) | \(4, 7\) | \(5, 6\) | \(6, 7\) |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 비용 | 29 | 75 | 35 | 34 | 7 | 23 | 13 | 53 | 25 |

2.  번째 단계에서는 가장 짧은 간선을 선택한다. 따라서 \(3, 4\)가 선택되고 이것을 집합에 포함하면 된다. 다시 말해 노드 3과 노드 4에 대하여 union 함수를 수행하면 된다.

| 간선 | \(1, 2\) | \(1, 5\) | \(2, 3\) | \(2, 6\) | \(3, 4\) | \(4, 6\) | \(4, 7\) | \(5, 6\) | \(6, 7\) |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 비용 | 29 | 75 | 35 | 34 | 7 | 23 | 13 | 53 | 25 |
| 순서 |  |  |  |  | step2 |  |  |  |  |

3. 다음으로 비용이 가장 작은 간선인 \( 4, 7 \)을 선택한다. 현재 노드 4와 노드 7은 같은 집합에 속해 있지 않기 때문에, 노드 4와 노드 7에 대하여 union 함수를 호출한다.

| 간선 | \(1, 2\) | \(1, 5\) | \(2, 3\) | \(2, 6\) | \(3, 4\) | \(4, 6\) | \(4, 7\) | \(5, 6\) | \(6, 7\) |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 비용 | 29 | 75 | 35 | 34 | 7 | 23 | 13 | 53 | 25 |
| 순서 |  |  |  |  | step2 |  | step3 |  |  |

4. 그다음으로 비용이 가장 작은 간선인 \( 4, 6 \)을 선택한다. 현재 노드 4와 노드 6은 같은 집합에 속해 있지 않기 때문에 노드 4와 노드 6에 대하여 union 함수를 호출한다.

| 간선 | \(1, 2\) | \(1, 5\) | \(2, 3\) | \(2, 6\) | **\(3, 4\)** | **\(4, 6\)** | **\(4, 7\)** | \(5, 6\) | \(6, 7\) |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 비용 | 29 | 75 | 35 | 34 | **7** | **23** | **13** | 53 | 25 |
| 순서 |  |  |  |  | **step2** | **step4** | **step3** |  |  |

5. 그다음으로 비용이 가장 작은 간선인 \( 6, 7 \)을 선택한다. 선택된 노드 6과 노드 7의 루트 노드를 확인한다. 다만, 노드 6과 노드 7의 루트가 이미 동일한 집합에 포함되어 있으므로 신장 트리에 포함하지 않아야 한다. 따라서 union 함수를 호출하지 않는다.

| 간선 | \(1, 2\) | \(1, 5\) | \(2, 3\) | \(2, 6\) | **\(3, 4\)** | **\(4, 6\)** | **\(4, 7\)** | \(5, 6\) | \(6, 7\) |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 비용 | 29 | 75 | 35 | 34 | **7** | **23** | **13** | 53 | 25 |
| 순서 |  |  |  |  | **step2** | **step4** | **step3** |  | step5 |

6. 그다음으로 비용이 가장 작은 간선 \( 1, 2 \)를 선택한다. 현재 노드 1과 노 2는 같은 집합에 속해 있지 않기 때문에, 노드 1과 노드 2에 대하여 union 함수를 호출한다.

| 간선 | **\(1, 2\)** | \(1, 5\) | \(2, 3\) | \(2, 6\) | **\(3, 4\)** | **\(4, 6\)** | **\(4, 7\)** | \(5, 6\) | \(6, 7\) |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 비용 | **29** | 75 | 35 | 34 | **7** | **23** | **13** | 53 | 25 |
| 순서 | **step6** |  |  |  | **step2** | **step4** | **step3** |  | step5 |

7. 그다음으로 비용이 가장 작은 간선 \( 2, 6 \)을 선택한다. 현재 노드 2와 노드 6은 같은 집합에 속해있지 않기 때문에, 노드 2와 노드 6에 대하여 union 함수를 호출한다.

| 간선 | **\(1, 2\)** | \(1, 5\) | \(2, 3\) | **\(2, 6\)** | **\(3, 4\)** | **\(4, 6\)** | **\(4, 7\)** | \(5, 6\) | \(6, 7\) |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 비용 | **29** | 75 | 35 | **34** | **7** | **23** | **13** | 53 | 25 |
| 순서 | **step6** |  |  | **step7** | **step2** | **step4** | **step3** |  | step5 |

8. 그다음으로 비용이 가장 작은 간선인 \( 2, 3 \)을 선택한다. 선택된 노드 2와 노드 3의 루트 노드를 확인한다. 다만, 노드 2와 노드 3의 루트가 이미 동일한 집합에 포함되어 있으므로 union 함수를 호출하지 않는다.

| 간선 | **\(1, 2\)** | \(1, 5\) | \(2, 3\) | **\(2, 6\)** | **\(3, 4\)** | **\(4, 6\)** | **\(4, 7\)** | \(5, 6\) | \(6, 7\) |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 비용 | **29** | 75 | 35 | **34** | **7** | **23** | **13** | 53 | 25 |
| 순서 | **step6** |  | ~~step8~~ | **step7** | **step2** | **step4** | **step3** |  | ~~step5~~ |

9. 그다음으로 비용이 가장 작은 간선 \( 5, 6 \)을 선택한다. 현재 노드 5와 노드 6은 같은 집합에 속해있지 않기 때문에, 노드 5와 노드 6에 대하여 union 함수를 호출한다.

| 간선 | **\(1, 2\)** | \(1, 5\) | \(2, 3\) | **\(2, 6\)** | **\(3, 4\)** | **\(4, 6\)** | **\(4, 7\)** | \(5, 6\) | \(6, 7\) |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 비용 | **29** | 75 | 35 | **34** | **7** | **23** | **13** | 53 | 25 |
| 순서 | **step6** |  | ~~step8~~ | **step7** | **step2** | **step4** | **step3** | step9 | ~~step5~~ |

10. 그다음으로 비용이 작은 간선 \( 1, 5 \)를 선택한다. 선택된 노드 1과 노드 5의 루트 노드를 확인한다. 다만, 노드 1과 노드 5의 루트가 이미 동일한 집합에 포함되어 있으므로 union 함수를 호출하지 않는다.

| 간선 | **\(1, 2\)** | \(1, 5\) | \(2, 3\) | **\(2, 6\)** | **\(3, 4\)** | **\(4, 6\)** | **\(4, 7\)** | **\(5, 6\)** | \(6, 7\) |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 비용 | **29** | 75 | 35 | **34** | **7** | **23** | **13** | **53** | 25 |
| 순서 | **step6** | ~~step10~~ | ~~step8~~ | **step7** | **step2** | **step4** | **step3** | **step9** | ~~step5~~ |

#### 

#### 크루스칼 알고리즘 코드

```text
# 특정 원소가 속한 집합을 찾기
def find_parent(parent, x):
    # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출
    if parent[x] != x:
        return find_parent(parent, parent[x])
    return parent[x]

    
# 두 원소가 속한 집합을 합치기
def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    
    if a < b:
        parent[b] = a
    else:
        parent[a] = b
        

# 노드의 개수와 간선( union 연산 )의 개수 입력받기
v, e = map(int, input().split())
parent = [0] * (v + 1) # 부모 테이블 초기화

# 모든 간선을 담을 리스트와 최종 비용을 담을 변수
edges = []
result = 0

# 부모 테이블상에서, 부모를 자기 자신으로 초기화
for i in range(1, v + 1):
    parent[i] = i
    
# 모든 간선에 대한 정보를 입력받기
for _ in range(e):
    a, b, cost = map(int, input().split())
    
    # 비용순으로 정렬하기 위해서 튜플의 첫 번째 원소를 비용으로 설정
    edges.append((cost, a, b))
    
# 간선을 비용순으로 정렬
edges.sort()

# 간선을 하나씩 확인하며
for edge in edges:
    cost, a, b = edge
    
    # 사이클이 발생하지 않는 경우에만 집합에 포함
    if find_parent(parent, a) != find_parent(parent, b):
        union_parent(parent, a, b)
        result += cost
    
print(result)
```

#### 

#### 크루스칼 알고리즘의 시간 복잡도

크루스칼 알고리즘은 간선의 개수가 E개일 때, O\( E log E \)의 시간 복잡도를 가진다. 왜냐하면 크루스칼 알고리즘에서 시간이 가장 오래 걸리는 부분이 간선을 정렬하는 작업이며, E개의 데이터를 정렬했을 때의 시간 복잡도는 O\( E log E \)이기 때문이다. 크루스칼 내부에서 사용되는 서로소 집합 알고리즘의 시간 복잡도는 정렬 알고리즘의 시간 복잡도보다 작으므로 무시한다.



## 위상 정렬\( Topology Sort \)

* _**방향 그래프의 모든 노드를 '방향성에 거스르지 않도록 순서대로 나열하는 것'**_ 이다.
* 정렬 알고리즘의 일종이다.
* 순서가 정해져 있는 일련의 작업을 차례대로 수행해야 할 때 사용할 수 있는 알고리즘이다.
* 현실 세계에서 위상 정렬을 수행하게 되는 전형적인 예시로는 **'선수과목을 고려한 학습 순서 설정**'을 들수 있다.
* 그래프상에서 선후관계가 있다면, 위상 정렬을 수행하여 모든 선후 관계를 지키는 전체 순서를 계산할 수 있다.
* 진입차수란 특정한 노드로 **'들어오는'** 간선의 개수를 의미한다.
* 이제 주어진 방향 그래프에서 위상 정렬을 수행하는 구체적인 알고리즘은 다음과 같다.
  * 진입차수가 0인 노드를 큐에 넣는다.
  * 큐가 빌 때까지 다음의 과정을 반복한다.
    * 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거한다.
    * 새롭게 진입차수가 0이 된 노드를 큐에 넣는다.
  * 이때 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재한다고 판단할 수 있다. 왜냐하면 사이클이 존재하는 경우 사이클에 포함되어 있는 원소 중에서 어떠한 원소도 큐에 들어가지 못하기 때문이다.



#### 위상 정렬을 이용해서 최 신장 트리를 찾는 과정

1. 초기 단계에서는 진입차수가 0인 노드를 큐에 넣는다. 현재 노드 1의 진입차수만 0이기 때문에 큐에 노드 1만 삽입한다.

| 노 | **1** | 2 | 3 | 4 | 5 | 6 | 7 |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 진입차 | 0 | 1 | 1 | 2 | 1 | 2 | 1 |
| 큐 | 노드1 |  |  |  |  |  |  |

2. 먼저 큐에 들어 있는 노드 1을 꺼낸다. 이제 노드 1과 연결되어 있는 간선들을 제거한다. 그러면 새롭게 노드 2와 노드 5의 진입차수가 0이 된다. 따라서 노드 2와 노드 5를 큐에 삽입한다.

| 노 | **1** | 2 | 3 | 4 | 5 | 6 | 7 |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 진입차 | 0 | 0 | 1 | 2 | 0 | 2 | 1 |
| 큐 | 노드2 | 노드5 |  |  |  |  |  |

3. 그다음 큐에 들어 있는 노드 2를 꺼낸다. 이제 노드 2와 연결되어 있는 간선들을 제거한다. 그러면 새롭게 노드 3의 진입차수가 0이 된다. 따라서 노드 3을 큐에 삽입한다.

| 노 | **1** | 2 | 3 | 4 | 5 | 6 | 7 |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 진입차 | 0 | 0 | 0 | 2 | 0 | 1 | 1 |
| 큐 | 노드 5 | 노드 3 |  |  |  |  |  |

4. 그다음 큐에 들어 있는 노드 5를 꺼낸다. 이제 노드 5와 연결되어 있는 간선들을 제거한다. 그러면 새롭게 노드 6의 진입차수가 0이 된다.

| 노 | **1** | 2 | 3 | 4 | 5 | 6 | 7 |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 진입차 | 0 | 0 | 0 | 2 | 0 | 0 | 1 |
| 큐 | 노드 3 | 노드 6 |  |  |  |  |  |

5. 그다음 큐에 들어 있는 노드 3을 꺼낸다. 이제 노드 3과 연결되어 있는 간선들을 제거한다. 이번 단계에서는 새롭게 진입차수가 0이 되는 노드가 없으므로 그냥 넘어간다.

| 노 | **1** | 2 | 3 | 4 | 5 | 6 | 7 |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 진입차 | 0 | 0 | 0 | 1 | 0 | 0 | 1 |
| 큐 | 노드 6 |  |  |  |  |  |  |

6. 그다음 큐에 들어 있는 노드 6을 꺼낸다. 이제 노드 6과 연결되어 있는 간선을 제거한다. 그러면 새롭게 노드 4의 진입차수가 0이 된다. 따라서 노드 4를 큐에 삽입한다.

| 노 | **1** | 2 | 3 | 4 | 5 | 6 | 7 |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 진입차 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
| 큐 | 노드 4 |  |  |  |  |  |  |

7. 그다음 큐에 들어 있는 노드 4를 꺼낸다. 이제 노드 4와 연결되어 있는 간선을 제거한다. 그러면 새롭게 노드 7의 진입차수가 0이 된다. 따라서 노드 7을 큐에 삽입한다.

| 노 | **1** | 2 | 3 | 4 | 5 | 6 | 7 |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 진입차 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 큐 | 노드 7 |  |  |  |  |  |  |

8. 그다음 큐에 들어 있는 노드 7을 꺼낸다. 이제 노드 7과 연결되어 있는 간선을 제거해야 한다. 이번 단계에서는 새롭게 진입차수가 0이 되는 노드가 없으므로 그냥 넘어간다.

| 노 | **1** | 2 | 3 | 4 | 5 | 6 | 7 |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 진입차 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 큐 |  |  |  |  |  |  |  |

위 과정을 수행하는 동안 큐에서 빠져나간 노드를 순서대로 출력하면, 그것이 바로 위상 정렬을 수행한 결과가 된다. 위상 정렬의 답안은 여러 가지가 될 수 있다는 점이 특징이다. 만약에 한 단계에서 큐에 새롭게 들어가는 원소가 2개 이상인 경우가 있다면, 여러 가지의 답이 존재하게 된다. 예를 들어 위 예시에서는 1 - 2 - 5 - 3 - 6 - 4 - 7이 하나의 답이 될 수 있으며, 1 - 5 - 2 - 3 - 6 - 4 - 7 또한 하나의 답이 될 수 있다.



#### 위상 정렬 코드

```text
from collections import deque

# 노드의 개수와 간선의 개수를 입력받기
v, e = map(int, input().split())

# 모든 노드에 대한 진입차수는 0으로 초기화
indegree = [0] * (v + 1)

# 각 노드에 연결된 간선 정보를 담기 위한 연결 리스트(그래프) 초기화
graph = [[] for i in range(v + 1)]

# 방향 그래프의 모든 간선 정보를 입력받기
for _ in range(e):
    a, b = map(int, input().split())
    graph[a].append(b) # 정점 A에서 B로 이동 가능
    # 진입차수를 1 증가
    indegree[b] += 1
    
# 위상 정렬 함수
def topology_sort():
    result = []     # 알고리즘 수행 결과를 담을 리스트
    queue = deque() # 큐 기능을 위한 deque 라이브러리 사용
    
    # 처음 시작할 때는 진입차수가 0인 노드를 큐에 삽입
    for i in range(1, v + 1):
        if indegree[i] == 0:
            queue.append(i)
            
    # 큐가 빌 때까지 반복
    while queue:
        # 큐에서 원소 꺼내기
        now = queue.popleft()
        result.append(now)
        
        # 해당 원소와 연결된 노드들의 진입차수에서 1 빼기
        for i in graph[now]:
            indegree[i] -= 1
            
            # 새롭게 진입차수가 0이 되는 노드를 큐에 삽입
            if indegree[i] == 0:
                queue.append(i)
                
    # 위상 정렬을 수행한 결과 출력
    for i in result:
        print(i, end=' ')    
```



#### 위상 정렬의 시간 복잡도

위상 정렬의 시간 복잡도는 O\( V + E \)이다. 위상 정렬을 수행할 때는 차례대로 모든 노드를 확인하면서, 해당 노드에서 출발하는 간선을 차례대로 제거해야 한다. 결과적으로 노드와 간선을 모두 확인한다는 측면에서 O\( V + E \)의 시간이 소요되는 것이다.



